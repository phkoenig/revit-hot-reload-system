# üö® KRITISCHE CURSOR RULES F√úR DIESES PROJEKT
# GeoJSON Importer f√ºr Revit 2026 - Hot Reload System
# ERSTELLT: 2024-12-19 (Funktionierende Architektur!)

## üî• ARCHITEKTUR-REGELN (NIEMALS VERLETZEN!)

### üö® KRITISCHE ARCHITEKTUR-REGEL (NIEMALS VERLETZEN!)

**Die Loader-DLL (GeoJsonImporter.dll) ist NUR ein Dummy!**

#### ‚úÖ **RICHTIG - Loader-DLL (GeoJsonImporter.dll):**
- **NUR Revit API Referenzen** (RevitAPI.dll, RevitAPIUI.dll)
- **KEINE Package References** (kein GeoJSON.Net, kein Newtonsoft.Json!)
- **NUR Dummy-Code:** App.cs, Proxy-Commands, WorkDllManager
- **Kann NICHT ausgetauscht werden** (statisch in Revit geladen)

#### ‚úÖ **RICHTIG - Work-DLL (GeoJsonImporter.Work.dll):**
- **ALLE Package References** (GeoJSON.Net, Newtonsoft.Json, etc.)
- **ALLE echten Commands** (Business Logic)
- **Kann zur Laufzeit ausgetauscht werden** (Hot Reload f√§hig)

#### ‚ùå **FALSCH - NIEMALS TUN:**
- **Package References in Loader-DLL hinzuf√ºgen** (zerst√∂rt Architektur!)
- **Business Logic in Loader-DLL schreiben** (zerst√∂rt Hot Reload!)
- **Work-DLL Referenzen in Loader-DLL** (verursacht "Klasse nicht gefunden")

---

## ‚úÖ KORREKTE IMPLEMENTIERUNG (FUNKTIONIERT!)

### Loader-DLL (GeoJsonImporter.csproj)
```csharp
// ‚úÖ RICHTIG: UI-Management + Proxy-Commands + WorkDllManager
App.cs ‚Üí Alle Buttons zeigen auf "GeoJsonImporter.Addin.Commands.*"
WorkDllManager ‚Üí Bew√§hrte Architektur (keine √Ñnderungen!)
Proxy-Commands ‚Üí Delegieren an Work-DLL √ºber WorkDllManager
```

### Work-DLL (GeoJsonImporter.Work.csproj)
```csharp
// ‚úÖ RICHTIG: Alle echten Commands hier
GeoRefWorkCommand.cs ‚Üí Enth√§lt echte GeoRef-Logik
SetupWorkCommand.cs ‚Üí Enth√§lt echte Setup-Logik
ImportGeoJsonWorkCommand.cs ‚Üí Enth√§lt echte Import-Logik
Alle Business Logic hier!
```

## üéØ HOT RELOAD WORKFLOW (FUNKTIONIERT!)

### Bew√§hrter Zyklus:
1. **"Unload Work-DLL"** in Revit
2. **Code in Work-DLL √§ndern**
3. **Work-DLL neu bauen**
4. **"Load Work-DLL"** in Revit
5. **Command testen**

### Architektur:
```
Revit ‚Üí App.cs ‚Üí Loader-DLL Proxy-Command ‚Üí WorkDllManager ‚Üí Work-DLL echte Commands
  ‚Üì         ‚Üì              ‚Üì                    ‚Üì              ‚Üì
UI      Button    Loader-DLL (statisch)    Delegation    Business Logic (Hot Reload)
```

## üöÄ ZUKUNFTSSICHERUNG

### Bei neuen Commands:
1. **Echten Command in Work-DLL erstellen** (Business Logic)
2. **Proxy-Command in Loader-DLL erstellen** (delegiert an Work-DLL)
3. **Button in App.cs hinzuf√ºgen** (zeigt auf Loader-DLL Proxy-Command)
4. **Bestehenden WorkDllManager nutzen** (ExecuteWorkCommand)

### Bei Problemen:
1. **Architektur pr√ºfen** - sind alle Proxy-Commands in Loader-DLL?
2. **App.cs pr√ºfen** - zeigen alle Buttons auf Loader-DLL?
3. **WorkDllManager pr√ºfen** - wurde er ver√§ndert?
4. **Hot Reload Workflow pr√ºfen** - funktioniert er noch?

## üèÜ FAZIT

**DIESE ARCHITEKTUR FUNKTIONIERT UND DARF NIEMALS GE√ÑNDERT WERDEN!**

- **Proxy-Commands in Loader-DLL** = Hot Reload funktioniert
- **App.cs zeigt auf Loader-DLL** = Revit findet alle Commands
- **Work-DLL kann ausgetauscht werden** = Hot Reload funktioniert
- **Einfach, aber kritisch!**

---
*Erstellt nach der erfolgreichen Implementierung vom 19.12.2024*
*"Proxy-Commands in Loader-DLL sind die korrekte Architektur!"*